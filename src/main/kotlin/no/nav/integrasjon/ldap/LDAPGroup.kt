package no.nav.integrasjon.ldap

import com.google.gson.annotations.SerializedName
import com.unboundid.ldap.sdk.Attribute
import com.unboundid.ldap.sdk.Filter
import com.unboundid.ldap.sdk.LDAPException
import com.unboundid.ldap.sdk.SearchRequest
import com.unboundid.ldap.sdk.SearchScope
import com.unboundid.ldap.sdk.LDAPResult
import com.unboundid.ldap.sdk.ResultCode
import com.unboundid.ldap.sdk.AddRequest
import com.unboundid.ldap.sdk.CompareRequest
import com.unboundid.ldap.sdk.DeleteRequest
import com.unboundid.ldap.sdk.ModifyRequest
import com.unboundid.ldap.sdk.Modification
import com.unboundid.ldap.sdk.ModificationType
import com.unboundid.ldap.sdk.DN
import com.unboundid.ldap.sdk.SearchResult
import mu.KotlinLogging
import no.nav.integrasjon.EXCEPTION
import no.nav.integrasjon.FasitProperties
import no.nav.integrasjon.LdapConnectionType
import no.nav.integrasjon.getConnectionInfo
import no.nav.integrasjon.srvUserDN
import no.nav.integrasjon.groupDN
import no.nav.integrasjon.ldap.LDAPGroup.Companion.simplify
import org.apache.kafka.common.acl.AccessControlEntry
import org.apache.kafka.common.acl.AclBinding
import org.apache.kafka.common.acl.AclOperation
import org.apache.kafka.common.acl.AclPermissionType
import org.apache.kafka.common.resource.PatternType
import org.apache.kafka.common.resource.ResourcePattern
import org.apache.kafka.common.resource.ResourceType

/**
 * LDAPGroup provides services for LDAP group management
 * - creation of groups
 * - deletion of groups
 * - add or remove group members
 *
 * Group management is restricted to Kafka context
 * - producer - and consumer group per topic, restricted to FasitProperties::ldapGroupBase
 * - members of producer - or consumer group, restricted to service accounts, FasitProperties::ldapSrvUserBase
 *
 * See See https://docs.ldap.com/ldap-sdk/docs/javadoc/overview-summary.html
 *
 * Ok, this class can be divided into cleaner classes (pure LDAP group and Kafka context), but
 * laziness and good-enough is the strongest competitor so far
 */

fun toGroupName(prefix: String, topicName: String) = "$prefix$topicName"

@Suppress("NO_TAIL_CALLS_FOUND")
class LDAPGroup(private val config: FasitProperties) :
    LDAPBase(config.getConnectionInfo(LdapConnectionType.GROUP)) {

    init {
        // initialize bind of user with enough authorization for group operations

        val connInfo = config.getConnectionInfo(LdapConnectionType.GROUP)
        val srvUserDN = config.srvUserDN()
        try {
            ldapConnection.bind(srvUserDN, config.ldapPassword)
            log.debug { "Successfully bind of $srvUserDN to $connInfo" }
        } catch (e: LDAPException) {
            log.error("$EXCEPTION LDAP operations will fail. Bind failure for $srvUserDN to $connInfo - $e")
            ldapConnection.close()
        }
    }

    // fixed set of attributes for group creation, more will be added - see createKafkaGroup
    private val newGroupAttr = listOf(
        Attribute(
            "objectClass",
            "group"
        ),
        Attribute(
            "description",
            "Generated by kafka-admin-rest, see https://github.com/navikt/kafka-adminrest"
        )
    )

    fun getKafkaGroups() = getKafkaGroupNames()

    private fun checkAttributeForGroup(group: String, attribute: String): Boolean =
        getGroupDN(group).let { groupName ->
            when {
                !groupName.isEmpty() -> ldapConnection.getEntry(groupName).getAttribute(attribute) != null
                else -> false
            }
        }

    /**
     * Generic function iterating group types and performing a couple of operations
     */

    private fun groupTypesCatch(
        existingGroups: List<String>,
        topicName: String,
        membBlck: (exists: Boolean, gn: String) -> List<String>,
        resBlck: (exists: Boolean, gn: String) -> SLDAPResult
    ): List<KafkaGroup> =

        KafkaGroupType.values().map { groupType ->
            val groupName = toGroupName(groupType.prefix, topicName)
            val groupExists = groupName in existingGroups

            try {
                KafkaGroup(
                    groupType,
                    groupName,
                    membBlck(groupExists, groupName),
                    resBlck(groupExists, groupName)
                )
            } catch (e: LDAPException) {
                log.error { "$EXCEPTION$e" }
                KafkaGroup(groupType, groupName, emptyList(), e.toLDAPResult().simplify())
            }
        }

    fun createKafkaGroups(topicName: String, creator: String): List<KafkaGroup> =
        groupTypesCatch(
            getKafkaGroupNames(),
            topicName,
            { _, _ -> emptyList() },
            { exists, groupName -> createKafkaGroup(exists, groupName, creator) }
        )

    fun deleteKafkaGroups(topicName: String): List<KafkaGroup> =
        groupTypesCatch(
            getKafkaGroupNames(),
            topicName,
            { _, _ -> emptyList() },
            { exists, groupName -> deleteKafkaGroup(exists, groupName) }
        )

    fun getKafkaGroupsAndMembers(topicName: String): List<KafkaGroup> =
        groupTypesCatch(
            getKafkaGroupNames(),
            topicName,
            { exists, groupName -> getMembersInKafkaGroup(groupName, exists) },
            { exists, _ ->
                if (exists)
                    LDAPResult(ResultCode.SUCCESS_INT_VALUE, ResultCode.SUCCESS).simplify()
                else
                    LDAPResult(ResultCode.NO_SUCH_OBJECT_INT_VALUE, ResultCode.NO_SUCH_OBJECT).simplify()
            }
        )

    fun createGroup(groupName: String, initialMember: String? = null) {
        ldapConnection.add(AddRequest(DN(config.groupDN(groupName)), newGroupAttr.toMutableList().apply {
            add(Attribute("cn", groupName))
            add(Attribute("sAMAccountName", groupName))
            if (initialMember != null) {
                add(Attribute(config.ldapGrpMemberAttrName, resolveUserDN(initialMember)))
            }
        }))
    }

    fun removeGroupMembers(groupName: String, membersToRemove: List<String>) {
        ldapConnection.modify(config.groupDN(groupName), membersToRemove.map {
            Modification(ModificationType.DELETE, config.ldapGrpMemberAttrName, resolveUserDN(it))
        })
    }

    fun addToGroup(groupName: String, groupMembers: List<String>) {
        ldapConnection.modify(config.groupDN(groupName), groupMembers.map {
            Modification(ModificationType.ADD, config.ldapGrpMemberAttrName, resolveUserDN(it))
        })
    }

    fun getGroupMembers(groupName: String): List<String> =
        searchGetMembershipKN(Filter.createEqualityFilter(config.ldapGroupAttrName, groupName))
            .searchEntries
            .flatMap {
                (it.getAttribute(config.ldapGrpMemberAttrName)?.values?.toList() ?: listOf<String>())
                    .map {
                        DN(it).rdn.attributes.first {
                            it.name.equals(config.ldapUserAttrName, ignoreCase = true)
                        }.value
                    }
            }

    private fun createKafkaGroup(exists: Boolean, groupName: String, creator: String): SLDAPResult =
        if (exists)
            LDAPResult(ResultCode.ENTRY_ALREADY_EXISTS_INT_VALUE, ResultCode.ENTRY_ALREADY_EXISTS).simplify()
        else
            ldapConnection.add(
                AddRequest(
                    DN(config.groupDN(groupName)),
                    newGroupAttr.toMutableList().apply {
                        add(Attribute("cn", groupName))
                        add(Attribute("sAMAccountName", groupName))

                        resolveUserDN(creator).let { userDN ->
                            if (groupName.startsWith(KafkaGroupType.MANAGER.prefix) &&
                                userDN.isNotEmpty()
                            )
                                add(Attribute(config.ldapGrpMemberAttrName, userDN))
                        }
                    })
                    .also { req -> log.info { "Create group request: $req" } }
            ).simplify()

    private fun deleteKafkaGroup(exists: Boolean, groupName: String): SLDAPResult =
        if (!exists)
            LDAPResult(ResultCode.NO_SUCH_OBJECT_INT_VALUE, ResultCode.NO_SUCH_OBJECT).simplify()
        else
            ldapConnection.delete(
                DeleteRequest(
                    DN(config.groupDN(groupName))
                ).also { req -> log.info { "Delete group request: $req" } }
            ).simplify()

    fun getKafkaGroupMembers(groupName: String) = getMembersInKafkaGroup(groupName)

    fun getGroupInGroupMembers(groupName: String) = getMembersInGroupInGroup(getCNFromDN(groupName))

    // REGEX approved Trong?
    private fun getCNFromDN(dNGroupName: String) = """([^,]*)""".toRegex().find(dNGroupName)!!.value.replace("cn=", "")

    fun updateKafkaGroupMembership(
        topicName: String,
        updateEntry: UpdateKafkaGroupMember,
        accessControl: AccessControl
    ): Access =
        accessControl.resolveUserDN().let { userDN ->
            val result = accessControl.validate(userDN, topicName)
            when {
                !result.grant -> result
                else -> update(topicName, updateEntry, userDN)
            }
        }

    private fun update(
        topicName: String,
        updateEntry: UpdateKafkaGroupMember,
        userDN: String
    ): Access {
        config.groupDN(toGroupName(updateEntry.role.prefix, topicName)).let { groupDN ->
            val req = ModifyRequest(
                groupDN,
                Modification(
                    when (updateEntry.operation) {
                        GroupMemberOperation.ADD -> ModificationType.ADD
                        GroupMemberOperation.REMOVE -> ModificationType.DELETE
                    },
                    config.ldapGrpMemberAttrName,
                    userDN
                )
            )

            log.info { "Update group membership request: $req for $userDN" }

            return when {
                updateEntry.isRedundant(userDN, groupDN, toGroupName(updateEntry.role.prefix, topicName)) ->
                    Access(true, AccessCode.OK, LDAPResult(0, ResultCode.SUCCESS).simplify())
                else ->
                    Access(true, AccessCode.OK, ldapConnection.modify(req).simplify())
            }
        }
    }

    private fun UpdateKafkaGroupMember.isRedundant(userDN: String, groupDN: String, groupName: String): Boolean =
        when (this.operation) {
            GroupMemberOperation.ADD -> userInGroup(userDN, groupDN, groupName)
            GroupMemberOperation.REMOVE -> !userInGroup(userDN, groupDN, groupName)
        }

    fun isManagerGroup(groupName: String): Boolean = checkAttributeForGroup(groupName, "groupType")

    private fun userInGroup(userDN: String, groupDN: String, groupName: String): Boolean =
    // careful, AD will raise exception if group is empty, thus, no member attribute issue
        when {
            groupEmpty(groupName) -> false
            groupInGroupSearch(groupName, userDN).contains(true) -> true
            else -> comparedMatchedMemberIn(groupDN, userDN)
        }

    // BruteForce them nested groups
    private fun groupInGroupSearch(groupName: String, userDN: String) =
        findAllMemberGroups(
            groupName,
            findMembersAsGroup(groupName).size,
            mutableSetOf()
        ).map { group -> comparedMatchedMemberIn(group, userDN) }

    private fun comparedMatchedMemberIn(groupName: String?, userDN: String): Boolean {
        return ldapConnection
            .compare(CompareRequest(groupName, config.ldapGrpMemberAttrName, userDN))
            .compareMatched()
    }

    private tailrec fun findAllMemberGroups(
        groupName: String,
        numberOfMembersAsGroup: Int,
        members: MutableSet<String>
    ): List<String> {
        val groups = findMembersAsGroup(getCNFromDN(groupName))
            .map { it }
        when {
            numberOfMembersAsGroup < 1 -> return members.toList()
            numberOfMembersAsGroup > 1 -> {
                // Recur the nested groups
                return recurSeveral(
                    groupName,
                    members,
                    numberOfMembersAsGroup - 1,
                    groups.map { it }[numberOfMembersAsGroup - 1]
                )
            }
            else -> {
                return when {
                    groups.isEmpty() -> recurOne(groupName, members, 0)
                    else -> {
                        val hasMoreGroups = groups[numberOfMembersAsGroup - 1]
                        recurOne(hasMoreGroups, members, findMembersAsGroup(getCNFromDN(hasMoreGroups)).size)
                    }
                }
            }
        }
    }

    private fun recurSeveral(groupName: String, members: MutableSet<String>, remainingMembers: Int, group: String) =
        findAllMemberGroups(
            groupName,
            remainingMembers,
            members
                // accumulate group found and groups already found
                .toMutableSet().apply {
                    addAll(members)
                    add(group)
                })

    private fun recurOne(group: String, members: MutableSet<String>, remainingMembers: Int) = findAllMemberGroups(
        group,
        remainingMembers,
        members
            // accumulate group found and groups already found
            .toMutableSet().apply {
                addAll(members)
                add(group)
            })

    fun findMembersAsGroup(groupName: String): List<String> {
        val members = members(groupName, "member")
        return when {
            members.isNotEmpty() -> members.filter { group -> ldapGetAttribute(group, "groupType") != null }
            else -> listOf()
        }
    }

    private fun members(groupName: String, member: String): List<String> {
        val members = ldapGetAttribute(getGroupDN(groupName), member)
        return when {
            members != null -> members.values.map { it }
            else -> listOf()
        }
    }

    private fun ldapGetAttribute(groupNameDN: String, attr: String) =
        ldapConnection.getEntry(groupNameDN).getAttribute(attr)

    fun userIsManager(topicName: String, userName: String): Boolean =
        toGroupName(KafkaGroupType.MANAGER.prefix, topicName).let { groupName ->

            if (groupName in getKafkaGroupNames())
                userInGroup(
                    resolveUserDN(userName),
                    config.groupDN(toGroupName(KafkaGroupType.MANAGER.prefix, topicName)),
                    groupName
                )
            else false
        }

    fun userExists(userName: String): Boolean = resolveUserDN(userName).isNotEmpty().also { exists ->
        if (!exists) log.error { "$userName doesn't exists as NAV ident or service user in current LDAP domain" }
    }

    /**
     * Level 0 - Generic search function, find something somewhere in LDAP
     */

    private fun searchXInY(
        searchBase: String,
        searchScope: SearchScope
    ): (String) -> (Filter) -> SearchResult = { attribute ->
        { filter ->
            ldapConnection.search(SearchRequest(searchBase, searchScope, filter, attribute))
        }
    }

    /**
     * Level 1 - Search functions locked to specific nodes, based on generic search function
     */
    private val searchInKafkaNode = searchXInY(config.ldapGroupBase, SearchScope.ONE)
    private val searchInServiceAccountsNode = searchXInY(config.ldapSrvUserBase, SearchScope.SUB)
    private val searchInUserAccountsNode = searchXInY(
        inheritDNTail(config.ldapSrvUserBase, config.ldapAuthUserBase),
        SearchScope.SUB
    )
    private val searchInGroupAccountsNode = searchXInY(config.ldapGroupInGroupBase, SearchScope.SUB)
    private val searchInGroupAccountsNodeInOffice = searchXInY(config.ldapGroupInGroupBase, SearchScope.SUB)

    /**
     * Level 2 - Search functions getting attributes, based on search functions locked to nodes
     */
    private val searchGetMembershipKN = searchInKafkaNode(config.ldapGrpMemberAttrName)
    private val searchGetNamesKN = searchInKafkaNode(config.ldapGroupAttrName)
    private val searchGetMembershipGroupNodeInOffice = searchInGroupAccountsNodeInOffice(config.ldapGrpMemberAttrName)

    private val searchGetDNSAN = searchInServiceAccountsNode(SearchRequest.NO_ATTRIBUTES)
    private val searchGetDNUAN = searchInUserAccountsNode(SearchRequest.NO_ATTRIBUTES)
    private val searchGetDNGROUP = searchInGroupAccountsNode(SearchRequest.NO_ATTRIBUTES)

    /**
     * Level 3 - Useful base functions, based on search functions returning attributes
     */
    private fun getMembersInKafkaGroup(groupName: String, exists: Boolean = true): List<String> =
        if (!exists) emptyList()
        else
            searchGetMembershipKN(Filter.createEqualityFilter(config.ldapGroupAttrName, groupName))
                .searchEntries
                .flatMap { it.getAttribute(config.ldapGrpMemberAttrName)?.values?.toList() ?: emptyList() }

    private fun getKafkaGroupNames(): List<String> =
        searchGetNamesKN(Filter.createEqualityFilter("objectClass", "group"))
            .searchEntries.map { it.getAttribute(config.ldapGroupAttrName).value }

    fun getServiceUserDN(userName: String): String =
        searchGetDNSAN(Filter.createEqualityFilter(config.ldapUserAttrName, userName))
            .let { searchRes ->
                when (searchRes.resultCode == ResultCode.SUCCESS && searchRes.entryCount == 1) {
                    true -> searchRes.searchEntries[0].dn
                    false -> ""
                }
            }

    fun getUserDN(userName: String): String =
        searchGetDNUAN(Filter.createEqualityFilter(config.ldapUserAttrName, userName))
            .let { searchRes ->
                when (searchRes.resultCode == ResultCode.SUCCESS && searchRes.entryCount == 1) {
                    true -> searchRes.searchEntries[0].dn
                    false -> ""
                }
            }

    fun getGroupDN(userName: String): String =
        searchGetDNGROUP(Filter.createEqualityFilter(config.ldapGroupAttrName, userName))
            .let { searchRes ->
                when (searchRes.resultCode == ResultCode.SUCCESS && searchRes.entryCount == 1) {
                    true -> searchRes.searchEntries[0].dn
                    false -> ""
                }
            }

    private fun getMembersInGroupInGroup(groupName: String): List<String> =
        searchGetMembershipGroupNodeInOffice(Filter.createEqualityFilter(config.ldapGroupAttrName, groupName))
            .searchEntries
            .flatMap { it.getAttribute(config.ldapGrpMemberAttrName)?.values?.toList() ?: emptyList() }

    /**
     * Level 4 - Useful base function, based on base functions
     */
    private fun groupEmpty(groupName: String) = getMembersInKafkaGroup(groupName).isEmpty()

    private fun resolveUserDN(userName: String) =
        when {
            isManagerGroup(userName) -> getGroupDN(userName)
            isNAVIdent(userName) -> getUserDN(userName)
            else -> getServiceUserDN(userName)
        }

    private fun inheritDNTail(srcDN: String, trgDN: String): String {

        val uRDNS = DN(trgDN).rdNs
        val sRDNS = DN(srcDN).rdNs

        val uInd = uRDNS.indices
        val sInd = sRDNS.indices

        uRDNS[uInd.last - 1] = sRDNS[sInd.last - 1]
        uRDNS[uInd.last] = sRDNS[sInd.last]

        return uRDNS.joinToString(",")
    }

    companion object {

        val log = KotlinLogging.logger { }

        /**
         * Ref. https://social.technet.microsoft.com/Forums/windows/en-US/0d7c1a2d-2bbe-4a54-9d1a-c3cff1871ed6/active-directory-group-name-character-limit?forum=winserverDS
         * The longest CommonName (CN) is limited to 64 characters
         * Kafka topic name length must be ≤ 246
         * The topic name is more restrictice than group name, check only the final group name length
         */
        private const val MAX_GROUPNAME_LENGTH = 64

        fun validGroupLength(topicName: String): Boolean =
            KafkaGroupType.values().map { it.prefix.length }.max()!! + topicName.length <= MAX_GROUPNAME_LENGTH

        fun maxTopicNameLength(): Int = MAX_GROUPNAME_LENGTH - KafkaGroupType.values().map { it.prefix.length }.max()!!

        fun LDAPResult.simplify(): SLDAPResult = SLDAPResult(this.resultCode, this.diagnosticMessage ?: "")
    }
}

/**
 * Enum class KafkaGroupType with LDAP group prefix included
 * Each topic has 2 groups
 * - a producer group with members allowed to produce events to topic
 * - a consumer group with members allowed to consume events from topic
 */
enum class KafkaGroupType(val prefix: String) {
    @SerializedName("PRODUCER")
    PRODUCER("KP-"),
    @SerializedName("CONSUMER")
    CONSUMER("KC-"),
    @SerializedName("MANAGER")
    MANAGER("KM-")
}

fun KafkaGroupType.into(): List<AclOperation> = when (this) {
    KafkaGroupType.PRODUCER -> listOf(AclOperation.DESCRIBE, AclOperation.WRITE, AclOperation.CREATE)
    else -> listOf(AclOperation.DESCRIBE, AclOperation.READ)
}

fun KafkaGroupType.intoAcls(topicName: String): List<AclBinding> = into()
    .map { AccessControlEntry("Group:${toGroupName(prefix, topicName)}", "*", it, AclPermissionType.ALLOW) }
    .map { AclBinding(ResourcePattern(ResourceType.TOPIC, topicName, PatternType.LITERAL), it) }

/**
 * Enum class KafkaGroupOperation
 * ADD - add a new group member
 * REMOVE - remove a group member from group
 */
enum class GroupMemberOperation {
    @SerializedName("ADD")
    ADD,
    @SerializedName("REMOVE")
    REMOVE
}

/**
 * data class UpdateKafkaGroupMember
 */
data class UpdateKafkaGroupMember(
    val role: KafkaGroupType,
    val operation: GroupMemberOperation,
    val member: String
)

/**
 * A simpler version of LDAPResult, giving kafka API the resultCode and diagnostic message
 */
data class SLDAPResult(
    val resultCode: ResultCode = ResultCode.INSUFFICIENT_ACCESS_RIGHTS,
    val message: String = "Not authorized"
)

/**
 * data class KafkaGroup as result from functions iterating KafkaGroupType - see groupTypesCatch
 */
data class KafkaGroup(
    val type: KafkaGroupType = KafkaGroupType.MANAGER,
    val name: String = "",
    val members: List<String> = emptyList(),
    val ldapResult: SLDAPResult = LDAPResult(50, ResultCode.INSUFFICIENT_ACCESS_RIGHTS).simplify()
)

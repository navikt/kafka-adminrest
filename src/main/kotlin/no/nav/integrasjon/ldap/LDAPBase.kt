package no.nav.integrasjon.ldap

import com.unboundid.ldap.sdk.*
import com.unboundid.util.ssl.SSLUtil
import com.unboundid.util.ssl.TrustAllTrustManager
import mu.KotlinLogging
import no.nav.integrasjon.FasitProperties
import no.nav.integrasjon.api.v1.Operation
import no.nav.integrasjon.api.v1.UpdateGroupMember
import no.nav.integrasjon.groupDN
import no.nav.integrasjon.srvUserDN
import no.nav.integrasjon.userDN

/**
 * A base class for LDAP operations
 */

class LDAPBase(private val config: FasitProperties) : AutoCloseable {

    private val connectOptions = LDAPConnectionOptions().apply {
        connectTimeoutMillis = config.ldapConnTimeout
    }

    //NB! - TrustAllTrustManager is too trusty, but good enough when inside corporate inner zone
    private val ldapConnection = LDAPConnection(
            SSLUtil(TrustAllTrustManager()).createSSLSocketFactory(),
            connectOptions)

    init {
        // initialize LDAP connection
        val lgInfo = "(${config.ldapHost},${config.ldapPort})"

        try {
            ldapConnection.connect(config.ldapHost, config.ldapPort)
            log.debug { "Successfully connected to $lgInfo" }
        }
        catch (e: LDAPException) {
            log.error { "Exception occurred, all LDAP operations will fail $lgInfo - $e" }
            ldapConnection.setDisconnectInfo(
                    DisconnectType.IO_ERROR,
                    "Exception when connecting to LDAPS $lgInfo", e)
        }

        // initialize bind with srvkafkaadadm user, for all operations except bind of users
        val srvUserDN = config.srvUserDN()
        try {
            ldapConnection.bind(srvUserDN,config.ldapPassword)
            log.debug("Successfully bind to $lgInfo with $srvUserDN")
        }
        catch (e: LDAPException) {
            log.error("Exception occurred, most LDAP operations will fail $srvUserDN to $lgInfo - $e")
            ldapConnection.close()
        }
    }

    // Beginning of attributes for group creation
    private val newGroupAttr = listOf(
            Attribute(
                    "objectClass",
                    "group"),
            Attribute(
                    "description",
                    "Generated by kafka-admin-rest, see https://github.com/navikt/kafka-adminrest")
    )

    override fun close() {
        log.debug {"Closing ldap connection" }
        ldapConnection.close()
    }

    fun canUserAuthenticate(user: String, pwd: String): Boolean =
            if (!ldapConnection.isConnected)
                false
            else {
                log.debug { "Trying bind for ${config.userDN(user)} and given password" }

                try {
                    ldapConnection.bind(config.userDN(user), pwd).resultCode == ResultCode.SUCCESS
                }
                catch(e: LDAPException) {
                    log.error { "Exception occurred during bind - ${e.diagnosticMessage}" }
                    false
                }
            }

    fun getKafkaGroups(): Collection<String> =
            ldapConnection
                    .search(
                            SearchRequest(
                                    config.ldapGroupBase,
                                    SearchScope.ONE,
                                    Filter.createEqualityFilter(
                                            "objectClass",
                                            "group"),
                                    config.ldapGroupAttrName)
                    )
                    .searchEntries.map { it.getAttribute(config.ldapGroupAttrName).value}


    /**
     * Enum class KafkaGroupType with LDAP group prefix included
     * Each topic has 2 groups
     * - a producer group with members allowed to produce events to topic
     * - a consumer group with members allowed to consume events from topic
     */
    enum class KafkaGroupType(val prefix: String) {
        PRODUCER("KAFKA_PRODUCER_"),
        CONSUMER("KAFKA_CONSUMER_")
    }

    /**
     * data class KafkaGroup as result from a couple of functions
     */
    data class KafkaGroup(
            val groupType: KafkaGroupType,
            val name: String,
            val result: LDAPResult)

    fun createKafkaGroups(topicName: String): Collection<KafkaGroup> =
            KafkaGroupType.values().map { groupType ->
                val groupName = toGroupName(groupType.prefix,topicName)
                val groupDN = config.groupDN(groupName)

                try {
                    KafkaGroup(
                            groupType,
                            groupName,
                            ldapConnection.add(
                                    AddRequest(
                                        DN(groupDN),
                                        newGroupAttr.toMutableList().apply {
                                            add(Attribute("cn", groupName))
                                            add(Attribute("sAMAccountName", groupName))
                                        })
                                        .also { req -> log.info { "Create group request: $req" } }
                            ))
                }
                catch (e: LDAPException) {
                    log.error { "Sorry, exception happened - $e" }
                    KafkaGroup(groupType,groupName,e.toLDAPResult())
                }
            }

    fun deleteKafkaGroups(topicName: String): Collection<KafkaGroup> =
            KafkaGroupType.values().map { groupType ->
                val groupName = toGroupName(groupType.prefix,topicName)

                try {
                    KafkaGroup(groupType, groupName, deleteKafkaGroup(groupName))
                }
                catch (e: LDAPException) {
                    log.error { "Sorry, exception happened - $e" }
                    KafkaGroup(groupType,groupName,e.toLDAPResult())
                }
            }

    fun deleteKafkaGroup(groupName: String): LDAPResult =
            ldapConnection.delete(
                    DeleteRequest(
                            DN(config.groupDN(groupName))
                    ).also { req -> log.info { "Delete group request: $req" } }
            )

    fun getKafkaGroupMembers(groupName: String): Collection<String> =
            ldapConnection.search(
                    SearchRequest(
                            config.ldapGroupBase,
                            SearchScope.ONE,
                            Filter.createEqualityFilter(
                                    config.ldapGroupAttrName,
                                    groupName),
                            config.ldapGrpMemberAttrName)
                    )
                    .searchEntries
                    .flatMap { it.getAttribute(config.ldapGrpMemberAttrName).values.toList() }

    fun updateKafkaGroupMembership(groupName: String, updateEntry: UpdateGroupMember): LDAPResult =
            ldapConnection.modify(
                ModifyRequest(
                        config.groupDN(groupName),
                        Modification(
                                if (updateEntry.operation == Operation.ADD)
                                    ModificationType.ADD
                                else
                                    ModificationType.DELETE,
                                config.ldapGrpMemberAttrName,
                                updateEntry.memberDN
                        )
                ).also { req -> log.info { "Update group membership request: $req" } }
            )

    companion object {

        val log = KotlinLogging.logger {  }

        private fun toGroupName(prefix: String, topicName: String) = "$prefix$topicName"
    }
}

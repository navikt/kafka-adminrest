package no.nav.integrasjon.ldap

import com.unboundid.ldap.sdk.*
import com.unboundid.util.ssl.SSLUtil
import com.unboundid.util.ssl.TrustAllTrustManager
import mu.KotlinLogging
import no.nav.integrasjon.FasitProperties
import no.nav.integrasjon.api.v1.ldap.Operation
import no.nav.integrasjon.api.v1.ldap.UpdateGroupMember
import no.nav.integrasjon.groupDN
import no.nav.integrasjon.srvUserDN
import no.nav.integrasjon.userDN

/**
 * A base class for LDAP operations
 */

class LDAPBase(private val config: FasitProperties) : AutoCloseable {

    private val connectOptions = LDAPConnectionOptions().apply {
        connectTimeoutMillis = config.ldapConnTimeout
    }

    //NB! - TrustAllTrustManager is too trusty, but good enough when inside corporate inner zone
    private val ldapConnection = LDAPConnection(
            SSLUtil(TrustAllTrustManager()).createSSLSocketFactory(),
            connectOptions)

    init {
        // initialize LDAP connection
        try {
            ldapConnection.connect(config.ldapHost, config.ldapPort)
            log.debug { "Successfully connected to (${config.ldapHost},${config.ldapPort})" }
        }
        catch (e: LDAPException) {
            log.error {"All LDAP operations will fail! " +
                    "Exception when connecting to (${config.ldapHost},${config.ldapPort}) - ${e.diagnosticMessage}" }
            ldapConnection.setDisconnectInfo(
                    DisconnectType.IO_ERROR,
                    "Exception when connecting to LDAP(${config.ldapHost},${config.ldapPort})", e)
        }

        // initialize bind with srvkafkaadadm user, for all operations except bind of users
        try {
            ldapConnection.bind(config.srvUserDN(config.ldapUser),config.ldapPassword)
            log.debug("Successfully bind to (${config.ldapHost},${config.ldapPort}) " +
                    "with ${config.srvUserDN(config.ldapUser)}")
        }
        catch (e: LDAPException) {
            log.error("Most LDAP operations will fail! " +
                    "Exception during bind of ${config.srvUserDN(config.ldapUser)} " +
                    "to (${config.ldapHost},${config.ldapPort}) - ${e.diagnosticMessage}")
        }

    }

    // fixed attributes when creating a new producer and consumer group for a topic
    // the missing dn will be added when creating the group based on topic name
/*    private val newGroupAttr = listOf(
            Attribute("objectClass","top"),
            Attribute("objectClass","groupOfUniqueNames"),
            Attribute("description","Generated by kafka-admin-rest, see https://github.com/navikt/kafka-adminrest"),
            Attribute("owner", config.srvUserDN(config.ldapUser)),
            Attribute(config.ldapGrpMemberAttrName, config.srvUserDN(config.ldapUser))
    )*/
    private val newGroupAttr = listOf(
            Attribute("objectClass","top"),
            Attribute("objectClass","groupOfUniqueNames"),
            Attribute("instanceType","4"),
            Attribute("nTSecurityDescriptor","O:BAG:BAD:S:"),
            Attribute("objectCategory","CN=groupOfUniqueNames,CN=Schema,CN=Configuration,DC=test,DC=local"),
            Attribute("description","Generated by kafka-admin-rest, see https://github.com/navikt/kafka-adminrest"),
            Attribute("owner", config.srvUserDN(config.ldapUser)),
            Attribute(config.ldapGrpMemberAttrName, config.srvUserDN(config.ldapUser))
    )

    override fun close() {
        log.debug {"Closing ldap connection" }
        ldapConnection.close()
    }

    fun canUserAuthenticate(user: String, pwd: String): Boolean =
            if (!ldapConnection.isConnected)
                false
            else {
                log.debug { "Trying bind for ${config.userDN(user)} and given password" }

                try {
                    ldapConnection.bind(config.userDN(user), pwd).resultCode == ResultCode.SUCCESS
                }
                catch(e: LDAPException) {
                    log.error { "Exception occurred during bind - ${e.diagnosticMessage}" }
                    false
                }
            }

    fun getKafkaGroups(): Collection<String> =
            ldapConnection
                    .search(
                            SearchRequest(
                                    config.ldapGroupBase,
                                    SearchScope.ONE,
                                    Filter.createEqualityFilter(
                                            "objectClass",
                                            "groupOfUniqueNames"),
                                    config.ldapGroupAttrName)
                    )
                    .searchEntries.map { it.getAttribute(config.ldapGroupAttrName).value}

    fun createKafkaGroups(topicName: String) = listOf(PRODUCER_PREFIX, CONSUMER_PREFIX).map { prefix ->
        try {
            ldapConnection.add(
                    AddRequest(
                            DN("${config.ldapGroupAttrName}=$prefix$topicName,${config.ldapGroupBase}"),
                            newGroupAttr.toMutableList().apply {
                                add(Attribute("cn","$prefix$topicName"))
                            }))
        }
        catch (e: LDAPException) {
            log.error { "Sorry, exception happened - $e" }
            e.toLDAPResult()
        }
    }

    fun deleteKafkaGroups(groupName: String) =
            ldapConnection
                    .delete(DeleteRequest(DN("${config.ldapGroupAttrName}=$groupName,${config.ldapGroupBase}")))

    fun getKafkaGroupMembers(groupName: String): Collection<String> =
            ldapConnection
                    .search(
                            SearchRequest(
                                    config.ldapGroupBase,
                                    SearchScope.ONE,
                                    Filter.createEqualityFilter(
                                            config.ldapGroupAttrName,
                                            groupName),
                                    config.ldapGrpMemberAttrName)
                    )
                    .searchEntries.flatMap { it.getAttribute(config.ldapGrpMemberAttrName).values.toList() }

    fun updateKafkaGroupMembership(groupName: String, updateEntry: UpdateGroupMember): LDAPResult =
            ModifyRequest(
                    config.groupDN(groupName),
                    Modification(
                            if (updateEntry.operation == Operation.ADD)
                                ModificationType.ADD
                            else
                                ModificationType.DELETE,
                            config.ldapGrpMemberAttrName,
                            updateEntry.memberDN
                    )
            ).let { ldapConnection.modify(it) }

    companion object {

        const val PRODUCER_PREFIX = "KAFKA_PRODUCER_"
        const val CONSUMER_PREFIX = "KAFKA_CONSUMER_"

        val log = KotlinLogging.logger {  }
    }
}
